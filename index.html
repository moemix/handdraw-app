<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>handdraw-app — camera background + hand draw</title>
  <style>
    :root{
      --ui-bg: rgba(18,18,20,.7);
      --ui-fg: #e7e7ea;
      --accent: #6fd3ff;
    }
    html, body { height: 100%; margin: 0; }
    body { background:#000; overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color: var(--ui-fg); }

    /* Stage */
    #stage { position: fixed; inset: 0; }
    #video { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); /* default mirror like selfie */ }
    #video.nomirror { transform: none; }

    /* Drawing surface */
    #draw { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }

    /* HUD */
    #hud { position: fixed; left: 0; right: 0; top: 0; display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 8px; padding: env(safe-area-inset-top) 12px 8px 12px; }
    #brand { justify-self: start; font-weight: 600; letter-spacing:.2px; text-shadow: 0 1px 2px rgba(0,0,0,.6); }
    #status { justify-self: center; font-variant-numeric: tabular-nums; background: var(--ui-bg); padding: 6px 10px; border-radius: 999px; box-shadow: 0 6px 16px rgba(0,0,0,.35); }
    #controls { justify-self: end; display: flex; gap: 8px; flex-wrap: wrap; }

    .pill { display:inline-flex; align-items:center; gap: 8px; background: var(--ui-bg); padding: 6px 10px; border-radius: 999px; box-shadow: 0 6px 16px rgba(0,0,0,.35); backdrop-filter: blur(6px); }
    .btn { cursor:pointer; border:1px solid rgba(255,255,255,.12); padding: 6px 10px; border-radius: 999px; background: var(--ui-bg); color: var(--ui-fg); }
    .btn:active { transform: translateY(1px); }
    .switch { display:inline-flex; align-items:center; gap:6px; }
    input[type="range"]{ accent-color: var(--accent); }
    input[type="color"]{ width: 30px; height: 24px; border:none; background: transparent; }

    #help { position: fixed; left: 12px; right: 12px; bottom: env(safe-area-inset-bottom); display:flex; justify-content:center; }
    #help .pill { opacity:.9; }

    /* Landmark debug */
    #landmarks { position: absolute; inset: 0; pointer-events: none; }

    /* Hide on install banners overlays (iOS) */
    @supports (-webkit-touch-callout: none){
      body { -webkit-touch-callout:none; -webkit-user-select:none; user-select:none; }
    }
  </style>
  <!-- MediaPipe Hands via CDN (Tasks Vision) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.17/wasm/vision_wasm_internal.js" async></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.17"></script>
</head>
<body>
  <div id="stage">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="draw"></canvas>
    <canvas id="landmarks"></canvas>
  </div>

  <div id="hud">
    <div id="brand">handdraw-app</div>
    <div id="status">loading…</div>
    <div id="controls">
      <label class="switch pill"><input type="checkbox" id="mirrorToggle" checked><span>Mirror</span></label>
      <label class="switch pill"><input type="checkbox" id="landmarkToggle"><span>Landmarks</span></label>
      <label class="pill">Brush <input id="brushSize" type="range" min="1" max="20" value="4"> <input id="brushColor" type="color" value="#eeeeee"></label>
      <button class="btn" id="clearBtn">Clear</button>
      <button class="btn" id="saveBtn">Save PNG</button>
    </div>
  </div>

  <div id="help"><div class="pill">Point with your index finger to draw • Pinch index+thumb to lift pen • Raise open hand to stop</div></div>

<script>
(async function(){
  const status = (msg)=> document.getElementById('status').textContent = msg;
  const video = document.getElementById('video');
  const draw = document.getElementById('draw');
  const lmCanvas = document.getElementById('landmarks');
  const dctx = draw.getContext('2d');
  const lmctx = lmCanvas.getContext('2d');

  // UI
  const mirrorToggle = document.getElementById('mirrorToggle');
  const landmarkToggle = document.getElementById('landmarkToggle');
  const brushSize = document.getElementById('brushSize');
  const brushColor = document.getElementById('brushColor');
  const clearBtn = document.getElementById('clearBtn');
  const saveBtn = document.getElementById('saveBtn');

  // Keep DPR crisp
  function fitCanvas(c){
    const rect = c.getBoundingClientRect();
    const ratio = Math.max(1, window.devicePixelRatio || 1);
    if (c.width !== Math.round(rect.width*ratio) || c.height !== Math.round(rect.height*ratio)){
      c.width = Math.round(rect.width*ratio);
      c.height = Math.round(rect.height*ratio);
    }
  }
  function fitAll(){
    fitCanvas(draw); fitCanvas(lmCanvas);
  }
  addEventListener('resize', fitAll);

  // Camera
  async function getStream(){
    // Prefer front camera on phones
    const constraints = { audio:false, video:{ facingMode: 'user', width:{ideal:1280}, height:{ideal:720} } };
    return navigator.mediaDevices.getUserMedia(constraints);
  }

  try{
    const stream = await getStream();
    video.srcObject = stream;
    await video.play();
  }catch(e){ status('camera blocked'); console.error(e); return; }

  // Mirror control
  function updateMirror(){
    if (mirrorToggle.checked) video.classList.remove('nomirror');
    else video.classList.add('nomirror');
  }
  mirrorToggle.addEventListener('change', updateMirror);
  updateMirror();

  // Drawing state
  let lastPoint = null;
  let penDown = false; // true while pointing with index only
  let smoothing = 0.65; // low-pass filter for tips
  let tipFiltered = null;

  // Init MediaPipe Hands (Tasks Vision)
  const { FilesetResolver, HandLandmarker, DrawingUtils } = window['@mediapipe/tasks-vision'];
  status('loading model…');
  const filesetResolver = await FilesetResolver.forVisionTasks(
    // Use CDN hosted assets
    'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.17/wasm'
  );

  const handLandmarker = await HandLandmarker.createFromOptions(filesetResolver, {
    baseOptions: { modelAssetPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.17/wasm/hand_landmarker.task' },
    numHands: 1,
    minTrackingConfidence: 0.5,
    minDetectionConfidence: 0.5,
    runningMode: 'VIDEO'
  });

  status('ready');
  fitAll();

  // Utilities
  function videoToCanvasCoords(normX, normY){
    // normX/normY are in [0..1] in video space (left->right of the *unmirrored* video frame)
    const mirrored = mirrorToggle.checked;

    // Compute draw canvas size and aspect cover mapping
    const vW = video.videoWidth || 1280;
    const vH = video.videoHeight || 720;
    const cW = draw.width; // device pixels
    const cH = draw.height;

    // Object-fit: cover mapping from video to canvas
    const videoAspect = vW / vH;
    const canvasAspect = cW / cH;
    let renderW, renderH, offsetX, offsetY;
    if (canvasAspect > videoAspect){
      // Canvas is wider -> video height fills, sides cropped
      renderH = cH; renderW = Math.round(cH * videoAspect);
      offsetX = Math.round((cW - renderW)/2); offsetY = 0;
    } else {
      // Canvas is taller -> video width fills, top/bottom cropped
      renderW = cW; renderH = Math.round(cW / videoAspect);
      offsetX = 0; offsetY = Math.round((cH - renderH)/2);
    }

    // Convert normalized video coords to rendered pixel coords
    let x = Math.round(normX * renderW) + offsetX;
    let y = Math.round(normY * renderH) + offsetY;

    // If the video is mirrored, flip X around the *render region*
    if (mirrored){
      x = (offsetX + renderW) - (x - offsetX);
    }
    return {x, y};
  }

  function drawPoint(p0, p1){
    dctx.lineCap = 'round';
    dctx.lineJoin = 'round';
    dctx.strokeStyle = brushColor.value;
    dctx.lineWidth = Number(brushSize.value) * (window.devicePixelRatio||1);
    dctx.beginPath();
    dctx.moveTo(p0.x, p0.y);
    dctx.lineTo(p1.x, p1.y);
    dctx.stroke();
  }

  clearBtn.addEventListener('click', ()=>{
    dctx.clearRect(0,0,draw.width, draw.height);
  });

  saveBtn.addEventListener('click', ()=>{
    // Composite drawing over current video frame for a fun export
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = draw.width; exportCanvas.height = draw.height;
    const ectx = exportCanvas.getContext('2d');

    // Paint current video pixels in the same cover mapping + mirror state
    const vW = video.videoWidth || 1280;
    const vH = video.videoHeight || 720;
    const cW = exportCanvas.width; const cH = exportCanvas.height;
    const videoAspect = vW / vH; const canvasAspect = cW / cH;
    let renderW, renderH, offsetX, offsetY;
    if (canvasAspect > videoAspect){
      renderH = cH; renderW = Math.round(cH * videoAspect); offsetX = Math.round((cW - renderW)/2); offsetY = 0;
    } else {
      renderW = cW; renderH = Math.round(cW / videoAspect); offsetX = 0; offsetY = Math.round((cH - renderH)/2);
    }
    if (mirrorToggle.checked){
      ectx.save();
      ectx.translate(offsetX + renderW, 0);
      ectx.scale(-1, 1);
      ectx.drawImage(video, offsetX, offsetY, renderW, renderH);
      ectx.restore();
    } else {
      ectx.drawImage(video, offsetX, offsetY, renderW, renderH);
    }

    // Overlay drawing
    ectx.drawImage(draw, 0, 0);

    const a = document.createElement('a');
    a.href = exportCanvas.toDataURL('image/png');
    a.download = 'handdraw.png';
    a.click();
  });

  // Gesture helpers
  function isIndexPointing(landmarks){
    // Simple heuristic: index extended, middle & ring flexed
    const tip = landmarks[8];
    const pip = landmarks[6];
    const midTip = landmarks[12];
    const ringTip = landmarks[16];
    const isIndexExtended = tip.y < pip.y; // y up in normalized coords
    const othersBent = (midTip.y > landmarks[10].y) && (ringTip.y > landmarks[14].y);
    return isIndexExtended && othersBent;
  }
  function isPinch(landmarks){
    const i = landmarks[8]; const t = landmarks[4];
    const dx = i.x - t.x; const dy = i.y - t.y;
    const dist = Math.hypot(dx, dy);
    return dist < 0.05; // normalized
  }
  function openPalm(landmarks){
    // Thumb + pinky far apart
    const t = landmarks[4]; const p = landmarks[20];
    const dx = t.x - p.x; const dy = t.y - p.y;
    return Math.hypot(dx,dy) > 0.4;
  }

  // Main loop
  let lastVideoTime = -1;
  async function tick(){
    const vTime = video.currentTime;
    if (vTime === lastVideoTime){ requestAnimationFrame(tick); return; }
    lastVideoTime = vTime;

    fitAll();

    const res = await handLandmarker.detectForVideo(video, vTime);

    // Clear landmarks layer
    lmctx.clearRect(0,0,lmCanvas.width, lmCanvas.height);

    if (res && res.landmarks && res.landmarks[0]){
      const lm = res.landmarks[0];

      // Toggle pen state
      if (openPalm(lm)) penDown = false; // safety off
      else if (isPinch(lm)) penDown = false; // lift pen on pinch
      else if (isIndexPointing(lm)) penDown = true;

      // Tip position (index fingertip)
      const tip = lm[8];

      // Low-pass filter to stabilize
      if (!tipFiltered) tipFiltered = {x: tip.x, y: tip.y};
      tipFiltered.x = tipFiltered.x * smoothing + tip.x * (1 - smoothing);
      tipFiltered.y = tipFiltered.y * smoothing + tip.y * (1 - smoothing);

      const p = videoToCanvasCoords(tipFiltered.x, tipFiltered.y);

      if (penDown){
        if (lastPoint) drawPoint(lastPoint, p);
        lastPoint = p;
      } else {
        lastPoint = null;
      }

      // Optional landmark rendering
      if (landmarkToggle.checked){
        lmctx.save();
        // Draw points in canvas space using same mapping
        for (const idx of [0,4,5,8,12,16,20]){
          const q = videoToCanvasCoords(lm[idx].x, lm[idx].y);
          lmctx.beginPath();
          lmctx.arc(q.x, q.y, 5*(window.devicePixelRatio||1), 0, Math.PI*2);
          lmctx.fillStyle = idx===8 ? '#4ff' : 'rgba(255,255,255,.75)';
          lmctx.fill();
        }
        lmctx.restore();
      }
    } else {
      lastPoint = null;
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

})();
</script>
</body>
</html>
