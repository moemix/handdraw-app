<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HandDraw – Camera Hand‑Tracking Canvas</title>
  <style>
    :root {
      --bg: #0b0d10;
      --panel: #12161b;
      --ink: #e8eef6;
      --muted: #8aa0b3;
      --accent: #46b1ff;
      --danger: #ff7a7a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--ink); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; }
    .app { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr; }

    /* Toolbar */
    .bar { display: flex; gap: .5rem; align-items: center; padding: .6rem .8rem; background: linear-gradient(180deg, rgba(255,255,255,.06), transparent 70%) , var(--panel); border-bottom: 1px solid rgba(255,255,255,.08); box-shadow: var(--shadow); z-index: 5; }
    .bar h1 { font-size: 14px; font-weight: 600; margin: 0 .6rem 0 0; color: var(--muted); }
    .btn { appearance: none; border: 1px solid rgba(255,255,255,.12); background: #1a1f26; color: var(--ink); padding: .45rem .7rem; border-radius: .6rem; cursor: pointer; transition: .15s transform, .15s background; }
    .btn:hover { background: #242a33; }
    .btn[aria-pressed="true"] { outline: 2px solid var(--accent); background: #0f2333; }
    .btn.danger { border-color: rgba(255,122,122,.35); color: #ffd8d8; background: #2a1515; }
    .btn.small { padding: .35rem .55rem; }
    .sep { width: 1px; height: 26px; background: rgba(255,255,255,.12); margin: 0 .25rem; }
    label { display: inline-flex; align-items: center; gap: .4rem; color: var(--muted); }
    input[type="range"] { accent-color: var(--accent); }

    /* Stage */
    .stage { position: relative; background: #0a0c0e; }
    canvas#draw { position: absolute; inset: 0; width: 100%; height: 100%; touch-action: none; z-index: 1; }
    canvas#overlay { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; z-index: 2; }

    /* Video preview (optional) */
    video#cam { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; display: none; z-index: 0; transform: scaleX(-1); }
    video#cam.show { display: block; }

    .status { margin-left: auto; color: var(--muted); }
    .kbd { background: #0e1319; border: 1px solid rgba(255,255,255,.12); border-radius: .35rem; padding: .1rem .35rem; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; color: #cde4ff; }
    .helper { padding: .5rem .8rem; color: var(--muted); }
    .helper b { color: var(--ink); }
    .floating { position: absolute; left: 12px; bottom: 12px; background: rgba(14,19,25,.9); padding: .6rem .8rem; border-radius: .6rem; border: 1px solid rgba(255,255,255,.12); }
  </style>
</head>
<body>
  <div class="app">
    <div class="bar">
      <h1>✏️ Pen</h1>
      <button id="penBtn" class="btn" aria-pressed="true" title="Draw (pinch index+thumb)">Pen</button>
      <button id="eraserBtn" class="btn" title="Erase (pinch middle+thumb)">Eraser</button>
      <button id="clearBtn" class="btn danger" title="Clear canvas">️ Clear</button>
      <div class="sep"></div>
      <button id="undoBtn" class="btn small" title="Undo (two‑finger pinch tap)">↶ Undo</button>
      <button id="redoBtn" class="btn small" title="Redo">↷ Redo</button>
      <div class="sep"></div>
      <label>Size <input id="size" type="range" min="1" max="30" value="6"></label>
      <div class="sep"></div>
      <label><input id="previewToggle" type="checkbox"> Background video</label>
      <label><input id="landmarksToggle" type="checkbox" checked> Landmarks</label>
      <label><input id="rearToggle" type="checkbox"> Rear camera</label>
      <label>BG blur <input id="bgBlur" type="range" min="0" max="20" value="2"></label>
      <label>BG brightness <input id="bgBright" type="range" min="50" max="120" value="80"></label>
      <div class="sep"></div>
      <button id="startBtn" class="btn">Start</button>
      <div class="status" id="status">status: idle</div>
    </div>

    <div class="stage" id="stage">
      <canvas id="draw"></canvas>
      <canvas id="overlay"></canvas>
      <video id="cam" playsinline></video>

      <div class="floating helper">
        <div><b>Pinch</b> <span class="kbd">index</span>+<span class="kbd">thumb</span> = draw</div>
        <div><b>Pinch</b> <span class="kbd">middle</span>+<span class="kbd">thumb</span> = erase (hold)</div>
        <div><b>Two‑finger pinch tap</b> = undo</div>
      </div>
    </div>
  </div>

  <!-- MediaPipe Tasks Vision (HandLandmarker) -->
  <script type="module">
    // === Imports ===
    import { HandLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.10/vision_bundle.mjs";

    // === Elements ===
    const cam = document.getElementById('cam');
    const draw = document.getElementById('draw');
    const overlay = document.getElementById('overlay');
    const stage = document.getElementById('stage');

    const penBtn = document.getElementById('penBtn');
    const eraserBtn = document.getElementById('eraserBtn');
    const clearBtn = document.getElementById('clearBtn');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const sizeInput = document.getElementById('size');
    const previewToggle = document.getElementById('previewToggle');
    const landmarksToggle = document.getElementById('landmarksToggle');
    const rearToggle = document.getElementById('rearToggle');
    const blurInput = document.getElementById('bgBlur');
    const brightInput = document.getElementById('bgBright');
    const startBtn = document.getElementById('startBtn');
    const statusEl = document.getElementById('status');

    // === State ===
    let running = false;
    let useRear = false;
    let currentTool = 'pen'; // 'pen' | 'eraser'
    let brushSize = Number(sizeInput.value);

    const strokes = []; // {points:[{x,y}], size, mode:'draw'|'erase'}
    const redoStack = [];

    // MediaPipe
    let handLandmarker; // instance
    let lastVideoTime = -1;
    const FPS = 30;

    // Layout: Resize canvases to stage size
    function fitCanvases() {
      const rect = stage.getBoundingClientRect();
      for (const c of [draw, overlay]) {
        const { width, height } = rect;
        c.width = Math.floor(width * devicePixelRatio);
        c.height = Math.floor(height * devicePixelRatio);
        c.style.width = width + 'px';
        c.style.height = height + 'px';
      }
    }
    new ResizeObserver(fitCanvases).observe(stage);

    // Camera
    async function openCamera() {
      if (cam.srcObject) {
        const tracks = cam.srcObject.getTracks();
        tracks.forEach(t => t.stop());
        cam.srcObject = null;
      }
      const constraints = {
        audio: false,
        video: { facingMode: useRear ? { ideal: 'environment' } : 'user', width: { ideal: 1280 }, height: { ideal: 720 } }
      };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      cam.srcObject = stream;
      await cam.play();
      cam.style.transform = useRear ? 'none' : 'scaleX(-1)';
      applyCamFilter();
      cam.classList.toggle('show', previewToggle.checked);
      status('camera ready');
    }

    function status(msg) { statusEl.textContent = 'status: ' + msg; }

    function applyCamFilter(){
      const b = Number(blurInput?.value ?? 0);
      const br = Number(brightInput?.value ?? 100) / 100; // percent -> factor
      cam.style.filter = `blur(${b}px) brightness(${br})`;
    }

    // Drawing helpers
    function drawStroke(ctx, stroke) {
      if (!stroke.points.length) return;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.lineWidth = stroke.size;
      ctx.globalCompositeOperation = stroke.mode === 'erase' ? 'destination-out' : 'source-over';
      ctx.beginPath();
      const [p0, ...rest] = stroke.points;
      ctx.moveTo(p0.x, p0.y);
      for (const p of rest) ctx.lineTo(p.x, p.y);
      ctx.strokeStyle = '#f2f6ff';
      ctx.stroke();
      ctx.restore();
    }

    function redrawAll() {
      const g = draw.getContext('2d');
      g.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      g.clearRect(0, 0, draw.width / devicePixelRatio, draw.height / devicePixelRatio);
      for (const s of strokes) drawStroke(g, s);
    }

    // Landmarks overlay
    const overlayCtx = overlay.getContext('2d');
    function drawLandmarks(results) {
      overlayCtx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      overlayCtx.clearRect(0, 0, overlay.width / devicePixelRatio, overlay.height / devicePixelRatio);
      if (!landmarksToggle.checked) return;
      const du = new DrawingUtils(overlayCtx);
      const lmList = useRear
        ? results.landmarks
        : results.landmarks.map(lm => lm.map(p => ({ ...p, x: 1 - p.x })));
      for (const lm of lmList) {
        du.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS, { lineWidth: 2 });
        du.drawLandmarks(lm, { radius: 3 });
      }
    }

    // Geometry utils
    const V = (x, y) => ({ x, y });
    const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

    // Convert normalized landmark to canvas coords (mirrored like the video)
    function toCanvasCoord(norm) {
      const w = overlay.width / devicePixelRatio;
      const h = overlay.height / devicePixelRatio;
      const x = useRear ? (norm.x * w) : (w - norm.x * w); // mirror only on front cam
      return V(x, norm.y * h);
    }

    // Gesture thresholds (in pixels)
    function dynamicThreshold() {
      const w = overlay.width / devicePixelRatio;
      return Math.max(12, Math.min(28, w / 40)); // scales with screen size
    }

    // Handle MediaPipe results
    let activeStroke = null;
    function handleGestures(results) {
      if (!results.landmarks.length) { activeStroke = null; return; }
      // Use first hand. Indexes per MediaPipe: thumb tip 4, index tip 8, middle tip 12
      const hand = results.landmarks[0];
      const thumb = toCanvasCoord(hand[4]);
      const index = toCanvasCoord(hand[8]);
      const middle = toCanvasCoord(hand[12]);

      const th = dynamicThreshold();
      const pinchIndex = dist(thumb, index) < th;
      const pinchMiddle = dist(thumb, middle) < th;

      const action = pinchMiddle ? 'erase' : (pinchIndex ? 'draw' : 'idle');

      if (action === 'draw' || action === 'erase') {
        const p = index; // use index tip as brush position
        if (!activeStroke || activeStroke.mode !== (action === 'erase' ? 'erase' : 'draw') || activeStroke.size !== brushSize) {
          // start new stroke
          activeStroke = { points: [p], size: brushSize, mode: action === 'erase' ? 'erase' : 'draw' };
          strokes.push(activeStroke);
          redoStack.length = 0; // invalidate redo on new input
        } else {
          activeStroke.points.push(p);
        }
        redrawAll();
      } else {
        activeStroke = null;
      }
    }

    // Animation loop
    async function loop() {
      if (!running) return;
      const now = cam.currentTime;
      if (now === lastVideoTime) { requestAnimationFrame(loop); return; }
      lastVideoTime = now;

      const results = handLandmarker.detectForVideo(cam, performance.now());
      drawLandmarks(results);
      handleGestures(results);

      // pace roughly to FPS
      setTimeout(() => requestAnimationFrame(loop), 1000 / FPS);
    }

    // Setup MediaPipe HandLandmarker
    async function setupHandLandmarker() {
      status('loading hand model…');
      const files = await FilesetResolver.forVisionTasks(
        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.10/wasm'
      );
      handLandmarker = await HandLandmarker.createFromOptions(files, {
        baseOptions: {
          modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/latest/hand_landmarker.task',
        },
        numHands: 1,
        runningMode: 'VIDEO'
      });
      status('model ready');
    }

    // Controls
    penBtn.addEventListener('click', () => { currentTool = 'pen'; penBtn.setAttribute('aria-pressed','true'); eraserBtn.setAttribute('aria-pressed','false'); });
    eraserBtn.addEventListener('click', () => { currentTool = 'eraser'; penBtn.setAttribute('aria-pressed','false'); eraserBtn.setAttribute('aria-pressed','true'); });
    clearBtn.addEventListener('click', () => { strokes.length = 0; redoStack.length = 0; redrawAll(); });
    undoBtn.addEventListener('click', () => { const s = strokes.pop(); if (s) { redoStack.push(s); redrawAll(); }});
    redoBtn.addEventListener('click', () => { const s = redoStack.pop(); if (s) { strokes.push(s); redrawAll(); }});
    sizeInput.addEventListener('input', e => { brushSize = Number(e.target.value || 6); });
    previewToggle.addEventListener('change', () => cam.classList.toggle('show', previewToggle.checked));
    landmarksToggle.addEventListener('change', () => {/* redrawn each frame */});
    blurInput?.addEventListener('input', applyCamFilter);
    brightInput?.addEventListener('input', applyCamFilter);
    rearToggle.addEventListener('change', async () => { useRear = rearToggle.checked; if (running) await openCamera(); });

    startBtn.addEventListener('click', async () => {
      try {
        startBtn.disabled = true; status('initializing…');
        await setupHandLandmarker();
        await openCamera();
        fitCanvases();
        running = true;
        requestAnimationFrame(loop);
        status('running');
      } catch (err) {
        console.error(err);
        status('error: ' + (err?.message || err));
        startBtn.disabled = false;
      }
    });

    // Pointer drawing fallback (mouse/touch) for testing without camera
    (function pointerFallback(){
      let down = false; let last = null;
      function pos(e){
        const rect = draw.getBoundingClientRect();
        if (e.touches && e.touches[0]) e = e.touches[0];
        return { x: (e.clientX - rect.left) * devicePixelRatio, y: (e.clientY - rect.top) * devicePixelRatio };
      }
      draw.addEventListener('pointerdown', e => { down = true; last = pos(e); activeStroke = { points:[last], size: brushSize, mode: currentTool === 'eraser' ? 'erase' : 'draw' }; strokes.push(activeStroke); redoStack.length = 0; redrawAll(); });
      draw.addEventListener('pointermove', e => { if(!down) return; const p = pos(e); activeStroke.points.push(p); redrawAll(); });
      window.addEventListener('pointerup', () => { down = false; activeStroke = null; });
      // touch
      draw.addEventListener('touchstart', e => { if (e.touches.length===1){ const p = pos(e); activeStroke = { points:[p], size: brushSize, mode: currentTool === 'eraser' ? 'erase' : 'draw' }; strokes.push(activeStroke); redoStack.length = 0; redrawAll(); } });
      draw.addEventListener('touchmove', e => { if (activeStroke){ const p = pos(e); activeStroke.points.push(p); redrawAll(); } });
      draw.addEventListener('touchend', () => { activeStroke = null; });
    })();

    // Initial layout
    fitCanvases();
    applyCamFilter();
  </script>

  <noscript>
    <div style="padding:1rem;color:#fdd">This app needs JavaScript enabled.</div>
  </noscript>
</body>
</html>
