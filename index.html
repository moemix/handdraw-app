<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <title>Hand Draw â€“ Air Sketch</title>
  <style>
    :root{
      --ui-bg: rgba(18,18,24,0.75);
      --ui-fg: #e7e9ee;
      --accent: #7dd3fc;
      --good: #34d399;
      --warn: #f59e0b;
      --danger:#ef4444;
    }
    html,body{height:100%;margin:0;background:#0b0c10;color:var(--ui-fg);font:16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"}
    .app{position:fixed;inset:0;display:grid;place-items:center;}
    .stage{position:relative;width:100%;height:100%;overflow:hidden;background:#000;}
    video, canvas{position:absolute;inset:0;}
    video{object-fit:cover;transform:scaleX(-1);} /* selfie view by default */
    #paint{pointer-events:none;}
    .hud{position:absolute;inset:0;pointer-events:none;}

    /* Controls */
    .controls{position:absolute;left:1rem;bottom:1rem;display:flex;gap:.5rem;flex-wrap:wrap;pointer-events:auto;}
    .btn{appearance:none;border:1px solid #2a2d34;background:var(--ui-bg);color:var(--ui-fg);padding:.5rem .75rem;border-radius:12px;backdrop-filter: blur(6px);cursor:pointer;display:inline-flex;align-items:center;gap:.5rem}
    .btn:hover{border-color:#40444f}
    .btn:active{transform:translateY(1px)}
    .chip{display:inline-flex;align-items:center;gap:.5rem;padding:.4rem .55rem;border-radius:999px;border:1px solid #2a2d34;background:var(--ui-bg)}
    .swatch{width:1rem;height:1rem;border-radius:999px;border:1px solid #0003}
    .range{display:flex;align-items:center;gap:.5rem;background:var(--ui-bg);padding:.4rem .6rem;border-radius:999px;border:1px solid #2a2d34}
    .range input{accent-color:var(--accent)}

    .status{position:absolute;right:1rem;bottom:1rem;display:flex;gap:.5rem;pointer-events:none}
    .pill{background:var(--ui-bg);border:1px solid #2a2d34;border-radius:999px;padding:.35rem .6rem}

    .topbar{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;align-items:center;padding: .5rem .75rem;gap:.5rem}
    .title{background:var(--ui-bg);border:1px solid #2a2d34;border-radius:12px;padding:.4rem .6rem}

    .start-overlay{position:absolute;inset:0;display:grid;place-items:center;background:linear-gradient(180deg,#0b0c10,#0b0c10e6 60%,#0b0c10f2)}
    .start-card{max-width:520px;margin:0 1rem;background:var(--ui-bg);border:1px solid #2a2d34;border-radius:16px;padding:1rem 1.25rem;backdrop-filter: blur(8px);text-align:center}
    .start-card h1{margin:.2rem 0 0;font-size:1.2rem}
    .start-card p{opacity:.85;margin:.5rem 0 1rem}
    .start-card button{pointer-events:auto}

    .debug{position:absolute;left:1rem;top:4.25rem;max-width:min(46ch,80vw);background:var(--ui-bg);border:1px solid #2a2d34;border-radius:12px;padding:.5rem .75rem;white-space:pre-wrap;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:12px;line-height:1.25;opacity:.85;pointer-events:auto}

    @media (max-width:640px){
      .debug{display:none}
    }
  </style>
  <!-- MediaPipe Hands (legacy JS API) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>
  <div class="app">
    <div class="stage" id="stage">
      <!-- Keep the video element purely as the visual background; we no longer redraw it onto the canvas -->
      <video id="video" playsinline muted></video>
      <!-- Overlay for guides/landmarks -->
      <canvas id="view"></canvas>
      <!-- Persistent paint layer -->
      <canvas id="paint"></canvas>
      <div class="hud">
        <div class="topbar">
          <div class="title">Hand Draw â€“ Air Sketch</div>
          <div class="pill" id="hint">Gesture: pinch to draw Â· open palm = idle</div>
        </div>
        <div class="debug" id="debug"></div>
        <div class="controls">
          <button class="btn" id="btnClear" title="Clear (double tap screen on mobile)">ðŸ§¹ Clear</button>
          <label class="chip" title="Color">
            <span>Color</span>
            <input id="color" type="color" value="#7dd3fc" style="background:transparent;border:none;width:2rem;height:1.75rem;padding:0;cursor:pointer" />
          </label>
          <label class="range" title="Brush size">
            <span>Size</span>
            <!-- Bigger range & default for crayon look -->
            <input id="size" type="range" min="4" max="50" value="14" />
          </label>
          <button class="btn" id="btnToggleMirror" title="Flip view (mirroring)">â†”ï¸Ž Mirror</button>
          <button class="btn" id="btnGuide" title="Show/hide guides">âœ³ï¸Ž Guides</button>
        </div>
        <div class="status">
          <div class="pill" id="statMode">Mode: idle</div>
          <div class="pill" id="statFps">FPS: â€“</div>
        </div>
      </div>
      <div class="start-overlay" id="start">
        <div class="start-card">
          <h1>Handâ€‘draw in the air</h1>
          <p>This runs in your browser. It needs your camera. Pinch your thumb and index finger to draw. Open palm to stop. Doubleâ€‘tap to clear.</p>
          <button class="btn" id="btnStart">Enable Camera</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const video = document.getElementById('video');
  const view = document.getElementById('view');
  const paint = document.getElementById('paint');
  const stage = document.getElementById('stage');
  const debugEl = document.getElementById('debug');
  const hint = document.getElementById('hint');
  const statMode = document.getElementById('statMode');
  const statFps = document.getElementById('statFps');
  const btnStart = document.getElementById('btnStart');
  const startOverlay = document.getElementById('start');

  const btnClear = document.getElementById('btnClear');
  const colorPicker = document.getElementById('color');
  const sizeRange = document.getElementById('size');
  const btnToggleMirror = document.getElementById('btnToggleMirror');
  const btnGuide = document.getElementById('btnGuide');

  let showGuides = true;
  let mirrored = true; // mirror the preview by default (selfie view)

  // Layout + projection state for cover-fit rendering
  let cover = {sx:0, sy:0, sw:0, sh:0, dx:0, dy:0, dw:0, dh:0, srcW:0, srcH:0};

  // Drawing state
  let lastPt = null;   // last fingertip position in canvas space
  let brushColor = colorPicker.value;
  let brushSize = parseFloat(sizeRange.value);

  // FPS meter
  let lastTime = performance.now();
  let frames = 0, fps = 0;

  function logDebug(lines){
    debugEl.textContent = lines.join('\\n');
  }

  function resize(){
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const rect = stage.getBoundingClientRect();

    // Size canvases for crisp rendering
    [view, paint].forEach(c => { c.width = rect.width * dpr; c.height = rect.height * dpr; c.style.width = rect.width + 'px'; c.style.height = rect.height + 'px'; });

    // Compute object-fit: cover parameters for mapping landmarks onto the overlaid canvases,
    // matching the DOM video element which also uses object-fit: cover.
    const srcW = video.videoWidth || 1280;
    const srcH = video.videoHeight || 720;
    cover.srcW = srcW; cover.srcH = srcH;

    const dstW = view.width; const dstH = view.height;
    const scale = Math.max(dstW/srcW, dstH/srcH);
    const sw = srcW * scale;
    const sh = srcH * scale;
    const sx = (dstW - sw) / 2;
    const sy = (dstH - sh) / 2;
    cover = {sx, sy, sw, sh, dx:sx, dy:sy, dw:sw, dh:sh, srcW, srcH};
  }

  window.addEventListener('resize', resize);

  // MediaPipe Hands setup
  const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  hands.onResults(onResults);

  let camera;
  document.getElementById('btnStart').addEventListener('click', async () => {
    startOverlay.style.display = 'none';
    try{
      camera = new Camera(video, {
        onFrame: async () => { await hands.send({image: video}); },
        width: 1280,
        height: 720
      });
      await camera.start();
      // Wait for first frame to size correctly
      video.addEventListener('loadedmetadata', resize, {once:true});
      resize();
    }catch(err){
      alert('Failed to start camera: ' + err.message);
      startOverlay.style.display = 'grid';
    }
  });

  // Controls
  btnClear.addEventListener('click', () => clearPaint());
  let lastTap=0; stage.addEventListener('touchend', () => { const now=Date.now(); if(now-lastTap<300) clearPaint(); lastTap=now; }, {passive:true});

  colorPicker.addEventListener('input', e => { brushColor = e.target.value; });
  sizeRange.addEventListener('input', e => { brushSize = parseFloat(e.target.value); });
  btnToggleMirror.addEventListener('click', () => {
    mirrored = !mirrored;
    video.style.transform = mirrored? 'scaleX(-1)': 'none'; // keep DOM video and overlay in sync
  });
  btnGuide.addEventListener('click', () => { showGuides=!showGuides; });

  function clearPaint(){
    const pctx = paint.getContext('2d');
    pctx.clearRect(0,0,paint.width,paint.height);
  }

  // Map normalized landmark to canvas coords accounting for cover-fit and mirroring
  function lmToCanvas(lm){
    // MediaPipe gives x,y normalized to [0,1] over source dimensions, x to the right on the source image
    let x = lm.x * cover.srcW;
    let y = lm.y * cover.srcH;
    // Scale to destination using the same cover scale
    const scale = Math.max(view.width/cover.srcW, view.height/cover.srcH);
    x = x * scale + cover.sx;
    y = y * scale + cover.sy;
    if(mirrored){
      // Mirror around center of the destination rect (cover area)
      const left = cover.sx, right = cover.sx + cover.sw;
      x = right - (x - left);
    }
    return {x, y, z: lm.z};
  }

  // Slightly larger pinch tolerance for easier drawing
  function pinchDistance(lms){
    const tip = lmToCanvas(lms[8]); // index tip
    const th  = lmToCanvas(lms[4]); // thumb tip
    const dx = tip.x - th.x, dy = tip.y - th.y; return Math.hypot(dx,dy);
  }

  function isOpenPalm(lms){
    // Simple heuristic: consider open when pinch distance is large
    const d = pinchDistance(lms);
    return d > 100; // easier to exit drawing
  }

  // Hand "bones" (skeleton) connections (indices per MediaPipe Hands landmark spec)
  const HAND_BONES = [
    // Thumb
    [0,1],[1,2],[2,3],[3,4],
    // Index
    [0,5],[5,6],[6,7],[7,8],
    // Middle
    [0,9],[9,10],[10,11],[11,12],
    // Ring
    [0,13],[13,14],[14,15],[15,16],
    // Pinky
    [0,17],[17,18],[18,19],[19,20],
    // Palm cross-links (for nicer mesh)
    [5,9],[9,13],[13,17]
  ];

  function drawBones(ctx, lms){
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(200,220,255,0.9)';
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.beginPath();
    for(const [a,b] of HAND_BONES){
      const pa = lmToCanvas(lms[a]);
      const pb = lmToCanvas(lms[b]);
      ctx.moveTo(pa.x, pa.y);
      ctx.lineTo(pb.x, pb.y);
    }
    ctx.stroke();
  }

  // Crayon-like stroke: draw multiple jittered parallel strokes with partial alpha
  function crayonStroke(pctx, from, to, color, baseSize){
    const layers = 5;
    for(let i=0;i<layers;i++){
      const t = i/(layers-1);
      const jitter = (Math.random()-0.5) * (baseSize*0.35);
      const jitter2 = (Math.random()-0.5) * (baseSize*0.35);
      pctx.strokeStyle = color;
      pctx.globalAlpha = 0.5 - 0.07*i; // layered transparency
      pctx.lineWidth = baseSize * (0.9 + Math.random()*0.25);
      pctx.lineCap = 'round';
      pctx.lineJoin = 'round';
      pctx.beginPath();
      pctx.moveTo(from.x + jitter, from.y + jitter2);
      pctx.lineTo(to.x + jitter2, to.y + jitter);
      pctx.stroke();
    }
    pctx.globalAlpha = 1;
  }

  function onResults(results){
    const vctx = view.getContext('2d');
    const pctx = paint.getContext('2d');

    // FPS calc
    frames++; const now = performance.now(); if(now - lastTime > 1000){ fps = frames; frames=0; lastTime = now; statFps.textContent = `FPS: ${fps}`; }

    // Clear overlay canvas
    vctx.clearRect(0,0,view.width,view.height);

    // Default mode
    let mode = 'idle';

    if(results.multiHandLandmarks && results.multiHandLandmarks.length){
      const lms = results.multiHandLandmarks[0];
      const tip = lmToCanvas(lms[8]);
      const pinch = pinchDistance(lms);

      // Gesture logic
      const pinchActive = pinch < 60; // easier threshold
      if(pinchActive){ mode = 'draw'; } else if(isOpenPalm(lms)){ mode = 'idle'; }

      // Update drawing state
      if(mode === 'draw'){
        const pt = {x: tip.x, y: tip.y};
        if(lastPt){
          crayonStroke(pctx, lastPt, pt, brushColor, brushSize);
        }
        lastPt = pt;
      } else {
        lastPt = null;
      }

      // Guides & landmarks
      if(showGuides){
        // Skeleton / bones
        drawBones(vctx, lms);

        // Landmarks
        const path = new Path2D();
        for(const lm of lms){
          const p = lmToCanvas(lm);
          path.moveTo(p.x+0.01,p.y);
          path.arc(p.x,p.y, 4, 0, Math.PI*2);
        }
        vctx.fillStyle = 'rgba(255,255,255,0.9)';
        vctx.fill(path);

        // Fingertip cursor
        vctx.beginPath();
        vctx.arc(tip.x, tip.y, pinchActive ? 16 : 10, 0, Math.PI*2);
        vctx.lineWidth = 3;
        vctx.strokeStyle = pinchActive ? 'rgba(52,211,153,0.95)' : 'rgba(125,211,252,0.95)';
        vctx.stroke();
      }

      // Status
      statMode.textContent = `Mode: ${mode}`;
      hint.textContent = pinchActive ? 'Drawingâ€¦ release pinch to stop' : 'Pinch to draw Â· open palm = idle';

      // Debug
      logDebug([
        `landmarks: ${lms.length}`,
        `pinch(px): ${pinch.toFixed(1)}`,
        `mode: ${mode}`,
        `mirror: ${mirrored}`,
        `brush: ${brushColor} @ ${brushSize}px`,
        `cover: sx=${cover.sx.toFixed(1)} sy=${cover.sy.toFixed(1)} sw=${cover.sw.toFixed(1)} sh=${cover.sh.toFixed(1)}`
      ]);

    } else {
      statMode.textContent = 'Mode: no-hand';
      hint.textContent = 'Show your hand to start';
      lastPt = null;
    }
  }

  // Kick an immediate size for initial layout (helps on desktop before camera starts)
  resize();
})();
</script>
</body>
</html>
