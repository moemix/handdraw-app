<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HandDraw ‚Äì Camera Hand‚ÄëTracking Canvas</title>
  <style>
    :root{
      --bg:#0b0d10; --panel:#111418; --muted:#2a2f36; --text:#e6e6e6; --acc:#5ee6a7; --warn:#ffb86c; --err:#ff6b6b;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    #app{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr;}

    .toolbar{display:flex;gap:.5rem;align-items:center;padding:.5rem .75rem;background:linear-gradient(180deg,rgba(0,0,0,.55),rgba(0,0,0,.35));border-bottom:1px solid var(--muted);backdrop-filter: blur(8px);}
    .toolbar .group{display:flex;gap:.5rem;align-items:center;background:var(--panel);border:1px solid var(--muted);padding:.35rem .5rem;border-radius:14px}
    .btn{appearance:none;border:1px solid var(--muted);background:#15191f;color:var(--text);padding:.4rem .7rem;border-radius:10px;cursor:pointer}
    .btn[aria-pressed="true"]{outline:2px solid var(--acc);border-color:transparent}
    .btn.small{padding:.3rem .55rem}
    .color{width:36px;height:28px;border:1px solid var(--muted);border-radius:8px;background:#000;overflow:hidden;padding:0}
    .color input{width:100%;height:100%;border:0;background:none;padding:0}
    .range{accent-color:var(--acc)}
    .stat{opacity:.9}

    .stage{position:relative;overflow:hidden}
    canvas#draw{position:absolute;inset:0;z-index:2}
    video#cam{position:absolute;right:12px;bottom:12px;width:240px;aspect-ratio:4/3;border-radius:12px;border:1px solid var(--muted);opacity:.35;z-index:3}
    .hint{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,.5);border:1px solid var(--muted);padding:.4rem .6rem;border-radius:10px;z-index:4}
    .badge{display:inline-block;background:var(--panel);border:1px solid var(--muted);padding:.2rem .5rem;border-radius:999px;margin-right:.35rem}

    /* Start overlay (fixes Safari / user‚Äëgesture requirement) */
    .gate{position:absolute;inset:0;display:grid;place-items:center;background:linear-gradient(180deg,rgba(0,0,0,.75),rgba(0,0,0,.6));z-index:5}
    .gate .card{background:#0f141a;border:1px solid var(--muted);border-radius:16px;padding:18px 20px;max-width:520px;text-align:center;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .gate .card h1{font-weight:600;margin:.2rem 0 0 0;font-size:18px}
    .gate .card p{opacity:.85;margin:.35rem 0 1rem 0}

    .hud{position:absolute;top:8px;right:8px;background:rgba(0,0,0,.5);border:1px solid var(--muted);border-radius:10px;padding:.35rem .5rem;font:12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas;z-index:4;min-width:220px}
    .hud .ok{color:var(--acc)}
    .hud .warn{color:var(--warn)}
    .hud .err{color:var(--err)}

    [data-tip]{position:relative}
    [data-tip]:hover::after{content:attr(data-tip);position:absolute;bottom:calc(100% + 6px);left:50%;transform:translateX(-50%);background:#000;border:1px solid var(--muted);padding:.25rem .5rem;border-radius:8px;white-space:nowrap;font-size:12px;opacity:.9}
  </style>
  <!-- MediaPipe Hands (classic Solution API) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>
  <div id="app">
    <div class="toolbar" role="toolbar">
      <div class="group" aria-label="Tools">
        <button id="tool-pen" class="btn small" aria-pressed="true" data-tip="Pen (pinch index+thumb to draw)">‚úèÔ∏è Pen</button>
        <button id="tool-eraser" class="btn small" aria-pressed="false" data-tip="Eraser (or pinch middle+thumb)">ü©π Eraser</button>
        <button id="clear" class="btn small" data-tip="Clear canvas (or Cmd/Ctrl+C)">üóëÔ∏è Clear</button>
        <button id="undo" class="btn small" data-tip="Undo (two‚Äëfinger pinch tap or Cmd/Ctrl+Z)">‚Ü∂ Undo</button>
        <button id="redo" class="btn small" data-tip="Redo">‚Ü∑ Redo</button>
      </div>
      <div class="group" aria-label="Brush">
        <label>Size <input id="size" type="range" min="1" max="40" value="6" class="range"/></label>
        <label class="color" data-tip="Color">
          <input id="color" type="color" value="#5ee6a7" />
        </label>
      </div>
      <div class="group" aria-label="Options">
        <label><input id="showVideo" type="checkbox" checked/> Cam preview</label>
        <label><input id="showLandmarks" type="checkbox"/> Landmarks</label>
        <label><input id="rear" type="checkbox"/> Rear camera</label>
      </div>
      <div class="stat" id="stat">Click Start to enable camera</div>
    </div>

    <div class="stage">
      <canvas id="draw"></canvas>
      <video id="cam" autoplay muted playsinline></video>
      <div class="hud" id="hud">status: idle</div>
      <div class="hint">
        <span class="badge">Pinch index+thumb = draw</span>
        <span class="badge">Pinch middle+thumb = erase (hold)</span>
        <span class="badge">Two‚Äëfinger pinch tap = undo</span>
      </div>
      <div class="gate" id="gate">
        <div class="card">
          <h1>HandDraw needs camera permission</h1>
          <p>Press Start and allow access. Works best in Chrome/Edge on desktop. Safari/iOS requires a user gesture (this button).</p>
          <button class="btn" id="startBtn">Start</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const video = document.getElementById('cam');
  const canvas = document.getElementById('draw');
  const ctx = canvas.getContext('2d');
  const stat = document.getElementById('stat');
  const hud = document.getElementById('hud');
  const gate = document.getElementById('gate');
  const startBtn = document.getElementById('startBtn');

  const toolPenBtn = document.getElementById('tool-pen');
  const toolEraserBtn = document.getElementById('tool-eraser');
  const clearBtn = document.getElementById('clear');
  const undoBtn = document.getElementById('undo');
  const redoBtn = document.getElementById('redo');
  const sizeInput = document.getElementById('size');
  const colorInput = document.getElementById('color');
  const showVideoChk = document.getElementById('showVideo');
  const showLmChk = document.getElementById('showLandmarks');
  const rearChk = document.getElementById('rear');

  let W=0,H=0; let currentTool='pen';
  let brushColor = colorInput.value; let brushSize = +sizeInput.value;
  const history=[]; const redoStack=[]; const snapshotLimit=40;

  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const {clientWidth, clientHeight} = document.querySelector('.stage');
    W = canvas.width = Math.floor(clientWidth * dpr);
    H = canvas.height = Math.floor(clientHeight * dpr);
    canvas.style.width = clientWidth + 'px';
    canvas.style.height = clientHeight + 'px';
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    // Only snapshot after real drawing exists
  }
  window.addEventListener('resize', resize);

  function setTool(tool){ currentTool = tool; toolPenBtn.setAttribute('aria-pressed', tool==='pen'); toolEraserBtn.setAttribute('aria-pressed', tool==='eraser'); }
  toolPenBtn.onclick=()=>setTool('pen');
  toolEraserBtn.onclick=()=>setTool('eraser');
  clearBtn.onclick=()=>{ ctx.clearRect(0,0,W,H); saveSnapshot(); };
  undoBtn.onclick=undo; redoBtn.onclick=redo;
  colorInput.oninput = e => brushColor = e.target.value;
  sizeInput.oninput = e => brushSize = +e.target.value;
  showVideoChk.onchange = e => video.style.display = e.target.checked? 'block':'none';

  function saveSnapshot(){ try{ const img = ctx.getImageData(0,0,W,H); history.push(img); if(history.length>snapshotLimit) history.shift(); redoStack.length=0; updateUndoRedo(); }catch(err){} }
  function undo(){ if(history.length>1){ const cur = history.pop(); redoStack.push(cur); const prev = history[history.length-1]; ctx.putImageData(prev,0,0); updateUndoRedo(); } }
  function redo(){ if(redoStack.length){ const img = redoStack.pop(); history.push(img); ctx.putImageData(img,0,0); updateUndoRedo(); } }
  function updateUndoRedo(){ undoBtn.disabled = history.length<=1; redoBtn.disabled = redoStack.length===0; }

  let isDrawing=false; let lastX=null, lastY=null; let pinchStartTS=0; let lastPinch=false; let frames=0, lastTS=performance.now();

  function startStroke(x,y){ isDrawing=true; lastX=x; lastY=y; }
  function moveStroke(x,y,tool){ if(!isDrawing) return; ctx.globalCompositeOperation = (tool==='eraser')? 'destination-out':'source-over'; ctx.strokeStyle = (tool==='eraser')? 'rgba(0,0,0,1)': brushColor; ctx.lineWidth = brushSize * (window.devicePixelRatio||1); ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(x,y); ctx.stroke(); lastX=x; lastY=y; }
  function endStroke(){ if(isDrawing){ isDrawing=false; lastX=lastY=null; saveSnapshot(); } }

  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function normPoint(lm){ return {x: lm.x * W, y: lm.y * H}; }

  function handleHand(landmarks){
    const thumb = landmarks[4];
    const index = landmarks[8];
    const middle = landmarks[12];
    const pIndex = normPoint(index);
    const pinchIdx = dist(index, thumb);
    const pinchMid = dist(middle, thumb);
    const idxPinched = pinchIdx < 0.055;
    const midPinched = pinchMid < 0.06;
    const toolNow = midPinched ? 'eraser' : currentTool;

    if(idxPinched){
      if(!lastPinch){ pinchStartTS = performance.now(); }
      lastPinch = true;
      if(!isDrawing) startStroke(pIndex.x,pIndex.y);
      moveStroke(pIndex.x,pIndex.y,toolNow);
    } else {
      if(lastPinch){ const dt = performance.now() - pinchStartTS; if(dt < 160) { undo(); } }
      lastPinch = false; endStroke();
    }
  }

  let hands, cam;
  async function initCamera(){
    resize(); ctx.clearRect(0,0,W,H);

    // Set facing mode based on toggle (helps phones)
    const facingMode = rearChk.checked ? {exact:'environment'} : 'user';

    // Ensure permission prompt occurs on user gesture; also attach stream to <video> to help Safari show preview
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode, width:{ideal:640}, height:{ideal:480} }, audio:false });
      video.srcObject = stream;
      await video.play();
    }catch(e){
      stat.textContent = 'Camera blocked. Allow access and reload.'; hud.innerHTML = `<div class="err">getUserMedia error: ${e.name}</div>`; throw e;
    }

    hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    hands.onResults(onResults);

    cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 640, height: 480 });
    await cam.start();
    stat.textContent = 'Camera running ‚Äì pinch index+thumb to draw';
  }

  function onResults(results){
    frames++;
    const t=performance.now(); if(t-lastTS>1000){ const fps=(frames*1000/(t-lastTS)).toFixed(1); frames=0; lastTS=t; const w=video.videoWidth||0,h=video.videoHeight||0; const handsCount=results.multiHandLandmarks?results.multiHandLandmarks.length:0; hud.innerHTML = `fps:${fps} ‚Ä¢ cam:${w}x${h} ‚Ä¢ hands:<span class="${handsCount? 'ok':'warn'}">${handsCount}</span>`; }

    if(showLmChk.checked && results.multiHandLandmarks){
      ctx.save(); ctx.globalCompositeOperation = 'lighter'; ctx.lineWidth = 1 * (window.devicePixelRatio||1); ctx.strokeStyle = 'rgba(255,255,255,.18)';
      for(const lm of results.multiHandLandmarks){ const path = lm.map(normPoint); ctx.beginPath(); for(let i=0;i<path.length;i++){ const p = path[i]; if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);} ctx.stroke(); }
      ctx.restore();
    }

    if(results.multiHandLandmarks && results.multiHandLandmarks.length){
      const handsSorted = results.multiHandLandmarks.slice().sort((a,b)=>a[8].x-b[8].x);
      handleHand(handsSorted[0]);
    } else {
      endStroke();
    }
  }

  // Keyboard fallbacks
  window.addEventListener('keydown', (e)=>{
    if(e.key==='e') setTool('eraser');
    if(e.key==='p') setTool('pen');
    if(e.key==='z'&&(e.ctrlKey||e.metaKey)) undo();
    if(e.key==='y'&&(e.ctrlKey||e.metaKey)) redo();
    if(e.key==='c'&&(e.ctrlKey||e.metaKey)) { ctx.clearRect(0,0,W,H); saveSnapshot(); }
  });

  // Gate button triggers camera init (user gesture requirement)
  startBtn.addEventListener('click', async ()=>{
    gate.style.display='none';
    try{ await initCamera(); }
    catch(e){ gate.style.display='grid'; }
  });

  // Simple runtime self‚Äëtests (logs in console & HUD)
  function selfTests(){
    const tests = [];
    function t(name, pass){ tests.push({name, pass}); console[(pass?'log':'error')](`${pass?'‚úî':'‚úñ'} ${name}`); }
    t('Canvas 2D context', !!ctx);
    t('MediaPipe Hands available', typeof Hands==='function');
    t('CameraUtils available', typeof Camera==='function');
    hud.innerHTML = hud.innerHTML + ` <span class="ok">tests:${tests.filter(x=>x.pass).length}/${tests.length}</span>`;
  }
  selfTests();
})();
</script>
</body>
</html>
